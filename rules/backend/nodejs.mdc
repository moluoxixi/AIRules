---
description: Node.js 和 Express.js 后端开发最佳实践，包含项目结构、中间件、错误处理等具体规范
globs:
  - "**/*.js"
  - "**/*.ts"
  - "src/**/*.ts"
  - "**/package.json"
alwaysApply: false
---

# Node.js 和 Express.js 最佳实践

## AI 角色
你是一位经验丰富的 Node.js 后端工程师，熟悉 Express.js、MongoDB、JWT 认证等技术栈，始终遵循 SOLID 原则和安全最佳实践。

## 技术栈
- Runtime: Node.js 18+
- Framework: Express.js 4.x
- Database: MongoDB with Mongoose ODM / PostgreSQL with Prisma
- Authentication: JSON Web Tokens (JWT)
- Validation: Zod / Joi
- Testing: Jest / Vitest

## 项目结构

必须遵循以下目录结构：

```
src/
├── config/           # 配置文件（数据库、环境变量等）
│   ├── database.ts
│   └── env.ts
├── controllers/      # 路由处理器（仅处理请求/响应）
│   └── user.controller.ts
├── services/         # 业务逻辑层
│   └── user.service.ts
├── repositories/     # 数据访问层
│   └── user.repository.ts
├── middlewares/      # Express 中间件
│   ├── auth.middleware.ts
│   ├── error.middleware.ts
│   └── validation.middleware.ts
├── models/           # 数据库模型
│   └── user.model.ts
├── routes/           # 路由定义
│   ├── index.ts
│   └── user.routes.ts
├── types/            # TypeScript 类型定义
│   └── user.types.ts
├── utils/            # 工具函数
│   └── logger.ts
├── validators/       # 请求验证 Schema
│   └── user.validator.ts
└── app.ts            # Express 应用入口
```

## Express 中间件设置

中间件必须按以下顺序加载：

```typescript
// app.ts
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import morgan from 'morgan';
import rateLimit from 'express-rate-limit';

const app = express();

// 1. 安全中间件（最先加载）
app.use(helmet());
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
  credentials: true,
}));

// 2. 速率限制
app.use(rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 每个 IP 最多 100 次请求
  message: { error: 'Too many requests, please try again later.' },
}));

// 3. 日志中间件
app.use(morgan('combined'));

// 4. Body 解析
app.use(express.json({ limit: '10kb' }));
app.use(express.urlencoded({ extended: true, limit: '10kb' }));

// 5. 压缩
app.use(compression());

// 6. 路由
app.use('/api/v1', routes);

// 7. 错误处理中间件（最后加载）
app.use(errorHandler);
```

## 路由设计

### RESTful API 规范

| 操作 | HTTP 方法 | 路由示例 | Controller 方法 |
|------|----------|---------|----------------|
| 获取列表 | GET | `/api/v1/users` | `getUsers` |
| 获取单个 | GET | `/api/v1/users/:id` | `getUserById` |
| 创建 | POST | `/api/v1/users` | `createUser` |
| 完整更新 | PUT | `/api/v1/users/:id` | `updateUser` |
| 部分更新 | PATCH | `/api/v1/users/:id` | `patchUser` |
| 删除 | DELETE | `/api/v1/users/:id` | `deleteUser` |

### 路由定义示例

```typescript
// routes/user.routes.ts
import { Router } from 'express';
import { UserController } from '../controllers/user.controller';
import { authMiddleware } from '../middlewares/auth.middleware';
import { validate } from '../middlewares/validation.middleware';
import { createUserSchema, updateUserSchema } from '../validators/user.validator';

const router = Router();
const userController = new UserController();

router.get('/', authMiddleware, userController.getUsers);
router.get('/:id', authMiddleware, userController.getUserById);
router.post('/', validate(createUserSchema), userController.createUser);
router.put('/:id', authMiddleware, validate(updateUserSchema), userController.updateUser);
router.delete('/:id', authMiddleware, userController.deleteUser);

export default router;
```

## 错误处理

### 自定义错误类

```typescript
// utils/errors.ts
export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number,
    public code?: string
  ) {
    super(message);
    this.name = 'AppError';
    Error.captureStackTrace(this, this.constructor);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} not found`, 404, 'NOT_FOUND');
  }
}

export class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400, 'VALIDATION_ERROR');
  }
}

export class UnauthorizedError extends AppError {
  constructor(message = 'Unauthorized') {
    super(message, 401, 'UNAUTHORIZED');
  }
}
```

### 全局错误处理中间件

```typescript
// middlewares/error.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors';
import { logger } from '../utils/logger';

export function errorHandler(
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void {
  // 记录错误
  logger.error({
    message: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
  });

  // AppError 实例
  if (err instanceof AppError) {
    res.status(err.statusCode).json({
      success: false,
      error: {
        code: err.code,
        message: err.message,
      },
    });
    return;
  }

  // Mongoose 验证错误
  if (err.name === 'ValidationError') {
    res.status(400).json({
      success: false,
      error: {
        code: 'VALIDATION_ERROR',
        message: err.message,
      },
    });
    return;
  }

  // 未知错误
  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_ERROR',
      message: process.env.NODE_ENV === 'production' 
        ? 'Internal server error' 
        : err.message,
    },
  });
}
```

### 异步错误包装器

```typescript
// utils/asyncHandler.ts
import { Request, Response, NextFunction } from 'express';

type AsyncFunction = (
  req: Request,
  res: Response,
  next: NextFunction
) => Promise<void>;

export function asyncHandler(fn: AsyncFunction) {
  return (req: Request, res: Response, next: NextFunction): void => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

// 使用示例
router.get('/users', asyncHandler(async (req, res) => {
  const users = await userService.findAll();
  res.json({ success: true, data: users });
}));
```

## 请求验证

使用 Zod 进行请求验证：

```typescript
// validators/user.validator.ts
import { z } from 'zod';

export const createUserSchema = z.object({
  body: z.object({
    email: z.string().email('Invalid email format'),
    password: z.string().min(8, 'Password must be at least 8 characters'),
    name: z.string().min(2, 'Name must be at least 2 characters'),
  }),
});

export const updateUserSchema = z.object({
  params: z.object({
    id: z.string().regex(/^[a-f\d]{24}$/i, 'Invalid ID format'),
  }),
  body: z.object({
    email: z.string().email().optional(),
    name: z.string().min(2).optional(),
  }),
});
```

```typescript
// middlewares/validation.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { AnyZodObject, ZodError } from 'zod';

export function validate(schema: AnyZodObject) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      await schema.parseAsync({
        body: req.body,
        query: req.query,
        params: req.params,
      });
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        res.status(400).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Validation failed',
            details: error.errors,
          },
        });
        return;
      }
      next(error);
    }
  };
}
```

## 认证和授权

### JWT 认证中间件

```typescript
// middlewares/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { UnauthorizedError } from '../utils/errors';

interface JwtPayload {
  userId: string;
  role: string;
}

declare global {
  namespace Express {
    interface Request {
      user?: JwtPayload;
    }
  }
}

export async function authMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader?.startsWith('Bearer ')) {
      throw new UnauthorizedError('No token provided');
    }

    const token = authHeader.split(' ')[1];
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload;
    
    req.user = decoded;
    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      next(new UnauthorizedError('Invalid token'));
      return;
    }
    next(error);
  }
}

// 角色验证中间件
export function requireRole(...roles: string[]) {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user || !roles.includes(req.user.role)) {
      next(new UnauthorizedError('Insufficient permissions'));
      return;
    }
    next();
  };
}
```

## 数据库操作

### Repository 模式示例

```typescript
// repositories/user.repository.ts
import { User, IUser } from '../models/user.model';

export class UserRepository {
  async findAll(options: { page: number; limit: number }): Promise<IUser[]> {
    const { page, limit } = options;
    return User.find()
      .skip((page - 1) * limit)
      .limit(limit)
      .lean()
      .exec();
  }

  async findById(id: string): Promise<IUser | null> {
    return User.findById(id).lean().exec();
  }

  async findByEmail(email: string): Promise<IUser | null> {
    return User.findOne({ email }).lean().exec();
  }

  async create(data: Partial<IUser>): Promise<IUser> {
    const user = new User(data);
    return user.save();
  }

  async update(id: string, data: Partial<IUser>): Promise<IUser | null> {
    return User.findByIdAndUpdate(id, data, { new: true }).lean().exec();
  }

  async delete(id: string): Promise<boolean> {
    const result = await User.findByIdAndDelete(id).exec();
    return !!result;
  }
}
```

## 日志记录

使用结构化日志：

```typescript
// utils/logger.ts
import pino from 'pino';

export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: process.env.NODE_ENV !== 'production'
    ? { target: 'pino-pretty', options: { colorize: true } }
    : undefined,
  base: {
    pid: process.pid,
    env: process.env.NODE_ENV,
  },
});

// 使用示例
logger.info({ userId: '123', action: 'login' }, 'User logged in');
logger.error({ err, requestId: req.id }, 'Request failed');
```

## 环境变量配置

```typescript
// config/env.ts
import { z } from 'zod';

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.string().transform(Number).default('3000'),
  DATABASE_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
  JWT_EXPIRES_IN: z.string().default('7d'),
  ALLOWED_ORIGINS: z.string().optional(),
});

export const env = envSchema.parse(process.env);
```

## 代码质量检查清单

每次编写 Node.js 代码后检查：
1. ✅ 是否使用了 async/await 而非回调
2. ✅ 是否有适当的错误处理（try-catch 或 asyncHandler）
3. ✅ 是否验证了所有用户输入
4. ✅ 是否使用了参数化查询防止 SQL/NoSQL 注入
5. ✅ 是否记录了关键操作的日志
6. ✅ 是否处理了进程退出信号（SIGTERM, SIGINT）
7. ✅ 是否设置了适当的安全头（helmet）
8. ✅ 是否配置了 CORS
9. ✅ 敏感信息是否通过环境变量配置
10. ✅ 是否有单元测试和集成测试
