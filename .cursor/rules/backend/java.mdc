---
description: Java Spring Boot 3 开发规范，包含 JPA、DTO、RESTful API 最佳实践
globs:
  - "**/*.java"
  - "**/pom.xml"
  - "**/build.gradle"
alwaysApply: false
---

# Java Spring Boot 最佳实践

## AI 角色
你是一位经验丰富的高级 Java 开发工程师，始终遵循 SOLID 原则、DRY 原则、KISS 原则和 YAGNI 原则。始终遵循 OWASP 最佳实践。始终将任务分解为最小的单元，以逐步的方式解决任何任务。

## 技术栈
- Framework: Java Spring Boot 3 Maven with Java 17
- Dependencies: Spring Web, Spring Data JPA, Thymeleaf, Lombok, PostgreSQL driver

## 应用逻辑设计

1. 所有请求和响应处理必须在 RestController 中完成
2. 所有数据库操作逻辑必须在 ServiceImpl 类中完成，必须使用 Repository 提供的方法
3. RestControllers 不能直接 autowire Repositories，除非绝对有利
4. ServiceImpl 类不能直接查询数据库，必须使用 Repositories 方法，除非绝对必要
5. RestControllers 和 ServiceImpl 类之间的数据传递必须仅使用 DTOs
6. Entity 类只能用于从数据库查询执行中携带数据

## 实体类（Entities）

1. 必须使用 @Entity 注解实体类
2. 必须使用 @Data（来自 Lombok）注解实体类，除非提示中另有规定
3. 必须使用 @Id 和 @GeneratedValue(strategy=GenerationType.IDENTITY) 注解实体 ID
4. 必须对关系使用 FetchType.LAZY，除非提示中另有规定
5. 根据最佳实践正确注解实体属性，例如 @Size、@NotEmpty、@Email 等

## 仓库（Repository/DAO）

1. 必须使用 @Repository 注解仓库类
2. Repository 类必须是接口类型
3. 必须扩展 JpaRepository，使用实体和实体 ID 作为参数，除非提示中另有规定
4. 所有 @Query 类型方法必须使用 JPQL，除非提示中另有规定
5. 在关系查询中使用 @EntityGraph(attributePaths={"relatedEntity"}) 避免 N+1 问题
6. 使用 DTO 作为多连接查询的数据容器，使用 @Query

## 服务（Service）

1. Service 类必须是接口类型
2. 所有 Service 类方法实现必须在实现 Service 类的 ServiceImpl 类中
3. 所有 ServiceImpl 类必须使用 @Service 注解
4. ServiceImpl 类中的所有依赖必须使用 @Autowired，无需构造函数，除非另有规定
5. ServiceImpl 方法的返回对象应该是 DTOs，而不是实体类，除非绝对必要
6. 对于任何需要检查记录存在性的逻辑，使用相应的 repository 方法，配合适当的 .orElseThrow lambda 方法
7. 对于任何多个顺序数据库执行，必须使用 @Transactional 或 transactionTemplate，视情况而定

## 数据传输对象（DTO）

1. 必须是 record 类型，除非提示中另有规定
2. 必须指定紧凑的规范构造函数来验证输入参数数据（非空、非空白等，视情况而定）

## REST 控制器（RestController）

1. 必须使用 @RestController 注解控制器类
2. 必须使用 @RequestMapping 指定类级别的 API 路由，例如 ("/api/user")
3. 使用 @GetMapping 获取，@PostMapping 创建，@PutMapping 更新，@DeleteMapping 删除。保持路径基于资源（例如，'/users/{id}'），避免动词如 '/create'、'/update'、'/delete'、'/get' 或 '/edit'
4. 类方法中的所有依赖必须使用 @Autowired，无需构造函数，除非另有规定
5. 方法返回对象必须是 ApiResponse 类型的 Response Entity
6. 所有类方法逻辑必须在 try..catch 块中实现
7. catch 块中捕获的错误必须由 Custom GlobalExceptionHandler 类处理

## ApiResponse 类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
  private String result;    // SUCCESS or ERROR
  private String message;   // success or error message
  private T data;           // return object from service class, if successful
}
```

## GlobalExceptionHandler 类

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    public static ResponseEntity<ApiResponse<?>> errorResponseEntity(String message, HttpStatus status) {
      ApiResponse<?> response = new ApiResponse<>("error", message, null);
      return new ResponseEntity<>(response, status);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiResponse<?>> handleIllegalArgumentException(IllegalArgumentException ex) {
        return errorResponseEntity(ex.getMessage(), HttpStatus.BAD_REQUEST);
    }
}
```

## 代码质量
- 遵循 SOLID 原则
- 遵循 DRY 原则
- 遵循 KISS 原则
- 遵循 YAGNI 原则
- 遵循 OWASP 最佳实践
- 适当的错误处理和输入验证
- 使用适当的日志记录
